# -*- coding: utf-8 -*-
"""AI_interviewer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XZBpiKURG6ujp5z8aGkoBLjmebxZOsBr
"""

!pip install -q gradio transformers sentencepiece reportlab

from transformers import pipeline
import gradio as gr
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter

# Load models
qa_model = pipeline("text2text-generation", model="MBZUAI/LaMini-Flan-T5-783M")
eval_model = pipeline("text2text-generation", model="google/flan-t5-small")

# State
session = {
    "questions": [],
    "answers": [],
    "feedback": [],
    "role": "",
    "index": 0,
    "total": 3
}

# Generate non-repeating, skill-based question
def generate_question(role, i):
    for _ in range(3):
        prompt = (
            f"You are a technical interviewer for the role of a {role}. "
            f"Generate a unique, skill-based technical interview question #{i+1}. "
            f"Focus on important tools, languages, frameworks, or challenges related to the job of a {role}."
        )
        result = qa_model(prompt, max_new_tokens=64)[0]["generated_text"].strip()
        if result not in session["questions"]:
            return result
    return f"What is the most important skill needed for a {role}, and how would you demonstrate it in a project?"

# Evaluate user's answer
def evaluate_answer(question, user_answer):
    prompt = f"""
You are an expert technical interviewer.

Given the interview question:
"{question}"

Ignore the candidate's answer. Provide a model, expert-level answer to this question as if you were answering in an interview.
"""
    result = eval_model(prompt, max_new_tokens=256)[0]["generated_text"]
    return result.strip()



# Start interview
def start_interview(job_title, num_questions):
    session["questions"], session["answers"], session["feedback"] = [], [], []
    session["index"], session["role"], session["total"] = 0, job_title.strip(), int(num_questions)

    question = generate_question(session["role"], session["index"])
    session["questions"].append(question)

    return f"🎯 Question 1:\n\n{question}", gr.update(visible=True), gr.update(visible=True), gr.update(visible=False)

# Handle submission
def submit_answer(answer):
    q = session["questions"][session["index"]]
    fb = evaluate_answer(q, answer.strip())

    session["answers"].append(answer.strip())
    session["feedback"].append(fb)
    session["index"] += 1

    if session["index"] < session["total"]:
        next_q = generate_question(session["role"], session["index"])
        session["questions"].append(next_q)
        return (
            f"🧠 Feedback:\n{fb}\n\n🎯 Question {session['index']+1}:\n\n{next_q}",
            "",
            gr.update(),
            gr.update()
        )
    else:
        return (
            f"🧠 Final Feedback:\n{fb}\n\n✅ Interview Complete! Click below to download your report.",
            "",
            gr.update(visible=False),
            gr.update(visible=True)
        )

# Generate report as PDF
def generate_report():
    filename = "Interview_Report.pdf"
    c = canvas.Canvas(filename, pagesize=letter)
    width, height = letter
    y = height - 50
    c.setFont("Helvetica", 12)
    c.drawString(50, y, f"🧠 Interview Report for: {session['role']}")
    y -= 30

    for i in range(session["total"]):
        c.drawString(50, y, f"Q{i+1}: {session['questions'][i][:90]}")
        y -= 20
        c.drawString(50, y, f"Answer: {session['answers'][i][:90]}")
        y -= 20
        c.drawString(50, y, f"Feedback: {session['feedback'][i][:90]}")
        y -= 40
        if y < 100:
            c.showPage()
            y = height - 50

    c.save()
    return filename

# Gradio UI
with gr.Blocks(css=".gradio-container { background-color: #f9fbfc; font-family: 'Segoe UI'; }") as app:
    gr.Markdown("## 🧠 AI Interview Simulator")
    gr.Markdown("Simulate technical interviews by entering a job role and number of questions. Get feedback and a PDF report.")

    with gr.Row():
        job = gr.Textbox(label="🎯 Job Title", placeholder="e.g., Frontend Developer")
        count = gr.Slider(1, 5, value=3, step=1, label="🔢 Number of Questions")
        start_btn = gr.Button("🚀 Start Interview", variant="primary")

    question_display = gr.Textbox(label="📄 Interview Question", lines=4, interactive=False)
    answer_input = gr.Textbox(label="📝 Your Answer", placeholder="Type your answer here...", lines=4)
    submit_btn = gr.Button("✅ Submit Answer", visible=False)
    download_btn = gr.Button("⬇️ Download Report (PDF)", visible=False)

    start_btn.click(start_interview, inputs=[job, count], outputs=[question_display, answer_input, submit_btn, download_btn])
    submit_btn.click(submit_answer, inputs=answer_input, outputs=[question_display, answer_input, submit_btn, download_btn])
    download_btn.click(generate_report, outputs=[gr.File(label="📁 Download Report")])

app.launch()

from transformers import pipeline
import gradio as gr
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity


# Load models
qa_model = pipeline("text2text-generation", model="MBZUAI/LaMini-Flan-T5-783M")
eval_model = pipeline("text2text-generation", model="google/flan-t5-small")

# Static questions from JSON
interview_data = {
  "Mobile App Developer": [
    {"question": "What is the difference between React Native and Flutter?", "answer": "React Native uses JavaScript and native components; Flutter uses Dart and has its own widget system for performance and consistency."},
    {"question": "How do you manage state in a mobile app?", "answer": "State can be managed using Redux, Provider, Riverpod, Bloc, or Context API depending on the framework."},
    {"question": "How do you optimize performance in mobile apps?", "answer": "Use lazy loading, minimize re-renders, use FlatList/LazyColumn, and cache images and API results."},
    {"question": "How do you test mobile apps?", "answer": "Using unit tests, widget tests, integration tests with tools like Jest, Detox, Flutter Test, or Espresso."},
    {"question": "What are some common mobile app architectures?", "answer": "MVC, MVVM, Redux, Clean Architecture, and BLoC (Flutter)."}
  ],
  "Game Developer": [
    {"question": "What is the game loop?", "answer": "A game loop constantly updates game state and renders graphics to achieve real-time interaction."},
    {"question": "How do you handle collision detection?", "answer": "Using bounding boxes, ray casting, pixel-perfect detection, or physics engines like Box2D."},
    {"question": "What is object pooling?", "answer": "Object pooling reuses game objects to avoid frequent allocation and deallocation, improving performance."}
  ],
  "API Developer": [
    {"question": "What is a RESTful API?", "answer": "An API that uses HTTP methods for stateless CRUD operations and follows REST conventions."},
    {"question": "What is the difference between REST and GraphQL?", "answer": "REST uses fixed endpoints; GraphQL lets clients request exactly what they need in one endpoint."},
    {"question": "How do you version APIs?", "answer": "Via URI paths (e.g., /v1/) or headers to manage breaking changes without affecting clients."}
  ],
  "Data Analyst": [
    {"question": "What are the types of JOINs in SQL?", "answer": "INNER, LEFT, RIGHT, and FULL JOINs used to combine data from multiple tables."},
    {"question": "How do you handle missing data in a dataset?", "answer": "Using techniques like deletion, mean/mode/median imputation, or predictive modeling."},
    {"question": "How do you visualize data?", "answer": "Using charts (bar, line, scatter, histogram) and tools like Tableau, Power BI, or matplotlib."}
  ],
  "Scrum Master": [
    {"question": "What are Scrum ceremonies?", "answer": "Events like Sprint Planning, Daily Stand-up, Sprint Review, and Sprint Retrospective that guide Agile teams."},
    {"question": "How do you handle team conflicts?", "answer": "Through facilitation, active listening, retrospectives, and encouraging open communication."},
    {"question": "What is a Sprint Retrospective?", "answer": "A meeting at the end of a sprint to reflect on what went well, what didn't, and how to improve."}
  ]
}

# Session state
session = {
    "role": "",
    "questions": [],
    "answers": [],
    "ideal_answers": [],
    "scores": [],
    "index": 0,
    "total": 0
}

# Evaluation function (score 0-10 based on similarity)
def score_answer(user_ans, ideal_ans):
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.metrics.pairwise import cosine_similarity

    vectorizer = TfidfVectorizer().fit_transform([user_ans, ideal_ans])
    vectors = vectorizer.toarray()
    sim_score = cosine_similarity([vectors[0]], [vectors[1]])[0][0]
    return int(sim_score * 10)


# Start interview
def start_interview(role):
    session["role"] = role
    session["questions"] = [item["question"] for item in interview_data[role]]
    session["ideal_answers"] = [item["answer"] for item in interview_data[role]]
    session["answers"], session["scores"] = [], []
    session["index"], session["total"] = 0, len(session["questions"])

    question = session["questions"][0]
    return f"🎯 Question 1:\n\n{question}", gr.update(visible=True), gr.update(visible=True), gr.update(visible=False)

# Handle answer submission
def submit_answer(user_ans):
    idx = session["index"]
    ideal = session["ideal_answers"][idx]
    score = score_answer(user_ans.strip(), ideal)

    session["answers"].append(user_ans.strip())
    session["scores"].append(score)
    session["index"] += 1

    if session["index"] < session["total"]:
        next_q = session["questions"][session["index"]]
        return (
            f"✅ Score for Previous Answer: {score}/10\n\n🎯 Question {session['index']+1}:\n\n{next_q}",
            "",
            gr.update(),
            gr.update()
        )
    else:
        return (
            f"✅ Final Score for Previous Answer: {score}/10\n\n🎉 Interview complete! Click below to download your report.",
            "",
            gr.update(visible=False),
            gr.update(visible=True)
        )

# PDF report generation
def generate_report():
    filename = "Interview_Report.pdf"
    c = canvas.Canvas(filename, pagesize=letter)
    width, height = letter
    y = height - 40

    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, y, f"Interview Report for: {session['role']}")
    y -= 30

    c.setFont("Helvetica", 11)
    for i in range(session["total"]):
        c.drawString(50, y, f"Q{i+1}: {session['questions'][i][:90]}")
        y -= 20
        c.drawString(50, y, f"Your Answer: {session['answers'][i][:90]}")
        y -= 20
        c.drawString(50, y, f"Ideal Answer: {session['ideal_answers'][i][:90]}")
        y -= 20
        c.drawString(50, y, f"Score: {session['scores'][i]}/10")
        y -= 40
        if y < 100:
            c.showPage()
            y = height - 40

    total_score = sum(session['scores'])
    c.drawString(50, y, f"🧠 Total Score: {total_score} / {10 * session['total']}")
    c.save()
    return filename

# UI
with gr.Blocks(css=".gradio-container { background-color: #f9fbfc; font-family: 'Segoe UI'; }") as app:
    gr.Markdown("## 🧠 AI Interview Simulator")
    gr.Markdown("Select a job role, answer questions, and receive feedback with a downloadable report.")

    with gr.Row():
        role_dropdown = gr.Dropdown(label="🎯 Job Role", choices=list(interview_data.keys()))
        start_btn = gr.Button("🚀 Start Interview", variant="primary")

    question_box = gr.Textbox(label="📄 Interview Question", lines=4, interactive=False)
    answer_box = gr.Textbox(label="📝 Your Answer", placeholder="Type your answer here...", lines=4)
    submit_btn = gr.Button("✅ Submit Answer", visible=False)
    download_btn = gr.Button("⬇️ Download Report (PDF)", visible=False)

    start_btn.click(start_interview, inputs=role_dropdown, outputs=[question_box, answer_box, submit_btn, download_btn])
    submit_btn.click(submit_answer, inputs=answer_box, outputs=[question_box, answer_box, submit_btn, download_btn])
    download_btn.click(generate_report, outputs=[gr.File(label="📁 Download Report")])

app.launch()